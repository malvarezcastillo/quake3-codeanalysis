\documentclass[a4paper,12pt]{report}
\usepackage[spanish,activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{eurosym}
\usepackage{url}
\renewcommand\thesection{\arabic{section}}


\usepackage[T1]{fontenc}
\usepackage{times}

\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listings}
\lstset{ frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	stringstyle=\ttfamily,
	showstringspaces = false,
	basicstyle=\small\ttfamily,
	commentstyle=\color{gray45},
	keywordstyle=\bfseries,
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
}

% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
{\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{consola}
{basicstyle=\scriptsize\bf\ttfamily,
	backgroundcolor=\color{gray75},
}

\lstdefinestyle{C}
{language=C,
}



\begin{document}
	
	\pagestyle{empty}
	\begin{titlepage}
		\begin{center}
			\includegraphics[scale=0.15]{images/fic01.png} \\ 
			\vspace{2cm} \includegraphics[scale=.4]{images/udc.pdf} \\
			
			
			\vspace{2.5cm}
			
			\textbf{\Large Diseño Software en un Quake III Arena}\\
			\vspace{0.5cm}
			\large{Máster Universitario en Ingeniería Informática}\\
		\end{center}
		
		\vspace{7.2cm}
		\begin{flushright}
			\noindent Elena M. Delamano Freije
			
			\noindent Martín Álvarez Castillo
			
		\end{flushright}
	\end{titlepage}
	\clearpage
	
	
	\tableofcontents
	\clearpage
	
	
	\section{Introducción}
	Quake III Arena, a partir de ahora referido como Q3, es un videojuego de disparos en primera persona (FPS) que fue lanzado en el año 1999 por \textit{id Software}. Este anticipado lanzamiento, al igual que el resto de juegos de \textit{id}, revolucionó el género de los FPS, tanto a nivel de diseño \,---\,el cual no se comentará en este documento excepto donde sea relevante\,---\,, como a nivel de tecnologías e implementación de motor gráfico de tiempo real en el ámbito de los videojuegos. \cite{quake3}\\
	
	El nuevo motor que se desarrolló para crear Q3 fue bautizado como \textit{id tech 3}, cuando nos refiramos a Q3 realmente nos estaremos refiriendo a la versión de \textit{id tech 3} empleada para el desarrollo de Q3. Para desarrollos comerciales \textit{id Software} ofreció una licencia de su nuevo motor a empresas de terceros. Una de las muchas empresas que licenció \textit{id tech 3} fue Activision, para el desarrollo de la primera edición de \textit{Call of Duty}. La licencia del motor permitía la modificación del mismo, y a día de hoy la familia de juegos de la franquicia de Call of Duty todos usan una versión modificada cuya raíz es \textit{id tech 3}. \cite{idtech3}\\
	
	Asimismo, siguiendo la filosofía de "compartir y colaborar para avanzar la tecnología" del programador líder John Carmack, \textit{id Software} liberó todo el código fuente de Q3 bajo la licencia GPL-2.0 \cite{sourcecode}. La liberación de este código provocó que el juego fuera portado a muchas nuevas arquitecturas y, al tener dependencias con licencias abiertas, permitió que los fans hicieran versiones mejoradas del juego completamente retrocompatibles con el contenido pasado, añadiendo funcionalidades nuevas y arreglando bugs conocidos. Una de estas implementaciones de software libre muy popular es \textit{ioquake3} \cite{ioquake3}. \\
	
	Durante el desarrollo de este informe se utilizará el código inicialmente liberado en 2005, con una \textit{release} única, ya que no se ha subido un histórico de \textit{commits}, y cuyos programadores  \,---\, de acuerdo a los créditos \,---\, son John Carmack (Director técnico y autor de la mayor parte del código), Robert A. Duffy y Jim Dose.\\
	
	El estado actual del proyecto es el mismo que cuando se desplegó la versión final del juego en 1999 (El código liberado en 2005 compila una versión exacta a la última versión disponible de Q3 en el momento). Aunque existen clones de este proyecto cuyo código ha sido limpiado sin introducir nuevos cambios o arreglar errores, se estudiará el código tal y como fue subido.\\
	
	goals, actors, status, releases \cite{example}\\
	
	\section{Metodología de Desarrollo y Herramientas}
	https://github.com/id-Software/Quake-III-Arena\\
	Importante -> https://www.youtube.com/watch?v=KFziBfvAFnM\\
	
	\section{Arquitectura de Software: Patrones y Antipatrones}
	patterns and anti-patterns\\
	La gran mayoría de aplicaciones están basados en sistemas 2D que solo requieren actualizar partes de la vista en cada momento. Cuando nos referimos a aplicaciones 3D estas arquitecturas clásicas no son compatibles, ya que para dar sensación de fluidez y continuidad el software debe generar una serie de frames cada segundo de manera constante. Incluso cuando el software no está haciendo ningún input, se produce el output de los frames. La arquitectura común de todos los aplicativos 3D es el render-loop:
	
	% introducir snippet de render-loop %

	
	\begin{lstlisting}[style=C, numbers=none]
while (!quit)
{
	// Update the camera transform based on interactive
	// inputs or by following a predefined path.
	updateCamera();
	// Update positions, orientations and any other
	// relevant visual state of any dynamic elements
	// in the scene.
	updateSceneElements();
	// Render a still frame into an off-screen frame
	// buffer known as the "back buffer".
	renderScene();
	// Swap the back buffer with the front buffer, making
	// the most recently rendered image visible
	// on-screen. (Or, in windowed mode, copy (blit) the
	// back buffer's contents to the front buffer.
	swapBuffers();
}
\end{lstlisting}
	
	
%	\begin{listing}[style=consola, numbers=none]
	

			
	
	En un videojuego, además de hacer el renderizado, necesitamos manejar la interactividad con el usuario. %, ya que el jugador afecta a%
	Para ello se introduce el concepto del game-loop, un bucle que además de ejecutar las tareas de renderizado contienen toda la lógica de control del juego. Un ejemplo básico de un game-loop sería el caso del videojuego clásico Pong:
	
	% introducir snippet de pong y texto %
	
		\begin{lstlisting}[style=C, numbers=none]
void main() // Pong
{
  initGame();
	
  while (true) // game loop
  {
    readHumanInterfaceDevices();
    if (quitButtonPressed())
    {
      break; // exit the game loop
    }
    movePaddles();
    moveBall();
    collideAndBounceBall();
    if (ballImpactedSide(LEFT_PLAYER))
    {
      incremenentScore(RIGHT_PLAYER);
      resetBall();
    }
    else if (ballImpactedSide(RIGHT_PLAYER))
    {
      incrementScore(LEFT_PLAYER);
      resetBall();
    }
  renderPlayfield();
  }
}
	\end{lstlisting}
	
	Esta aproximación de game-loop es demasiado básica y limitada para juegos modernos. Aún así, la arquitectura de dichos juegos se basa un game-loop que contiene a su vez una serie de bucles de cada subsistema del motor, pudiendo correr cada uno de esos bucles a un frecuencia distinta del resto. Por ejemplo: en un segundo queremos renderizar 60 fotogramas, pero sólo tenemos que recibir paquetes de red 30 veces por segundo. 
	
	Destacamos dos aproximaciones muy frecuentes en el desarrollo de motores de videojuegos:
	
	\begin{itemize}
		\item Callback-Driven frameworks. La mayoría de los subsistemas de motores y de paquetes middleware de videojuegos están estructurados como librerías. Para la implementación del game-loop usamos las llamadas a esos subsistemas a partir de sus API's para agilizar la lógica de cada subsistema en cada iteración. Por ejemplo: si estuviéramos implementando el flappy bird utilizando este estilo, una iteración del bucle podía parecerse a algo similar a:
		
		% snippet de while(true) en el que la primera instruccion sea calcular posición pájaro, segundo calcular colisión pájaro (si colisionó fin de partida, se bajan las highscores), si no colisionó sigue el bucle y se debe calcular si el usuario ha hecho input (si ha tocado la pantalla o no) si está tocada se cambian las variables de movimiento del pájaro y si no no se hace nada. Se hace una llamada al api de físicas para que calcule según el momentum del pájaro donde va a estar en la siguiente posición.  Reproducir el audio correspondiente. Por último se pinta el frame, llamando a la librería de renderizado (librería renderizado android, totalmente abstraídos de ella).  %
		
		El programador, en este ejemplo, sólo ha tenido que diseñar la lógica de cómo funciona el juego y ha dejado en manos de los subsistemas la ejecución de bajo nivel de los resultados de la interacción del usuario. Los subsistemas utilizados en este caso, y que el programador no está obligado a conocer más que sus API's, serían las implementaciones de networking, de audio, de gráficos, de input y de físicas. La mayoría de estas librerías son independientes e intercambiables entre sí, a las que se accede utilizando un patrón facade.
		
		Si en el futuro el programador decidiera programar este juego para iOS, este código tendría que adaptar las llamadas de API a las librerías disponibles en iOS, quizá utilizando el patrón adaptador para evitar cambiar la lógica principal y tipos de datos de su sistema.	
		
		\item Event-Based Updating. En este estilo de implementación todos los subsistemas son capaces de enviar y recibir eventos. Estos eventos son similares a los que se usan en los patrones de interfaces gráficas como MVC. 
		
		En el game-loop se han de procesar todos los eventos recibidos en la anterior iteración y distribuirlos a los subsistemas pertinentes para que los procesen, además, también se encarga de notificar a los subsistemas de en qué instante se encuentra la ejecución del programa. Los eventos recibidos no siempre tienen por qué ser procesados inmediatamente, por lo que cada subsistema debe de tener capacidad para almacenar eventos y en base a la información del bucle principal, ser consciente del instante en el que ha de procesar cada uno de los eventos. 
		
		%  Antipatrón %
		
		
		En el caso concreto de estudio, Q3, implementa desde sus primeras versiones un motor completamente basado en un modelo de eventos, siendo estas primeras versiones las que revolucionaron
	
	\end{itemize}	
	
	
		
	\section{Diseño de Software}
	design patterns and anti-patterns\\
	
	\section{Calidad del Software}
	metrics, documentation, testing and CI, etc\\
	
	\section{Estado de la accesibilidad en el proyecto}
	
	\section{Conclusiones}
			
	
	
	
	
	
	\begin{thebibliography}{9}
		
		\bibitem{example}Google \emph{Ejemplo Bibliografía}. URL: \url{http://www.google.com}\\
		\bibitem{quake3}Quake III Arena \emph{Quake Wikia}. URL: \url{http://quake.wikia.com/wiki/Quake_III_Arena}\\
		\bibitem{idtech3} id tech 3 \emph{Giant Bomb}. URL: \url{https://www.giantbomb.com/id-tech-3/3015-1918/}\\
		\bibitem{sourcecode} Quake III Arena Source Code \emph{Github}. URL: \url{https://github.com/id-Software/Quake-III-Arena}\\
		\bibitem{ioquake3} ioquake3 \emph{ioquake3}. URL: \url{https://ioquake3.org/}
		
		
	\end{thebibliography}
	
	
\end{document}
